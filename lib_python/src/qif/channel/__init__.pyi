"""
Channels.

Submodules
- compose
"""
from .. import typing as t
from . import compose as compose

def assert_proper(C: t.ndarray) -> None: ...

def deterministic(map: t.Callable[[int], int], n_rows: int, n_cols: int, type: t.TypeLike = t.def_type) -> t.ndarray: ...

def factorize(A: t.ndarray, B: t.ndarray, col_stoch: bool = False) -> t.ndarray: ...

def hyper(C: t.ndarray, pi: t.ndarray) -> t.Tuple[t.ndarray, t.ndarray]: ...

def identity(n_rows: int, type: t.TypeLike = t.def_type) -> t.ndarray: ...

def is_proper(C: t.ndarray, mrd: t.FloatOrRat = 2.220446049250313e-14) -> bool: ...

def iterative_bayesian_update(C: t.ndarray, out: t.ndarray, start: t.ndarray = t.array([]), max_diff: t.FloatOrRat = 1e-06, max_iter: int = 0) -> t.Tuple[t.ndarray, int]: ...

def left_factorize(A: t.ndarray, B: t.ndarray, col_stoch: bool = False) -> t.ndarray: ...

def no_interference(n_rows: int, n_cols: int = 1, type: t.TypeLike = t.def_type) -> t.ndarray: ...

def normalize(C: t.ndarray) -> t.ndarray: ...

def posterior(C: t.ndarray, pi: t.ndarray, col: int) -> t.ndarray: ...

def posteriors(C: t.ndarray, pi: t.ndarray = t.array([])) -> t.ndarray: ...

def randu(n_rows: int, n_cols: int = 0, type: t.TypeLike = t.def_type) -> t.ndarray: ...

def reduced(C: t.ndarray) -> t.ndarray: ...

@t.overload
def sample(C: t.ndarray, pi: t.ndarray) -> t.Tuple[int, int]: ...
@t.overload
def sample(C: t.ndarray, pi: t.ndarray, n_samples: int) -> t.ndarray: ...

def sum_column_min(C: t.ndarray) -> t.FloatOrRat: ...
