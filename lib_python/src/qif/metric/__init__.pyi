"""
Metrics and other distance functions.

Submodules:
- optimize
"""
from .. import typing as t
from . import optimize as optimize

def convex_separation() -> t.Metric[t.ndarray,float]: ...

def convex_separation_quasi() -> t.Metric[t.ndarray,float]: ...

def discrete(type: t.TypeLike = t.def_type) -> t.Metric[t.Any,t.Any]: ...

def euclidean(type: t.TypeLike = t.def_type) -> t.Metric[t.Any,t.Any]: ...

def euclidean_chain(type: t.TypeLike = t.def_type) -> t.Metric[t.Any,t.Any]: ...

def from_distance_matrix(M: t.ndarray) -> t.Metric[int,float]: ...

def kantorovich(d: t.Metric[int,float]) -> t.Metric[t.ndarray,float]: ...

def l1() -> t.Metric[t.ndarray,float]: ...

def l2() -> t.Metric[t.ndarray,float]: ...

def max(d1: t.Metric[t.T,t.R], d2: t.Metric[t.T,t.R]) -> t.Metric[t.T,t.R]: ...

def min(d1: t.Metric[t.T,t.R], d2: t.Metric[t.T,t.R]) -> t.Metric[t.T,t.R]: ...

def mirror(d: t.Metric[t.T,t.R]) -> t.Metric[t.T,t.R]: ...

def mult_kantorovich(d: t.Metric[int,float]) -> t.Metric[t.ndarray,float]: ...

def mult_reals(type: t.TypeLike = t.def_type) -> t.Metric[float,float]: ...

def mult_total_variation() -> t.Metric[t.ndarray,float]: ...

def scale(d: t.Metric[t.T,t.R], coeff: t.R) -> t.Metric[t.T,t.R]: ...

def threshold(d: t.Metric[t.T,t.R], thres: t.R) -> t.Metric[t.T,t.R]: ...

def threshold_inf(d: t.Metric[t.T,t.R], thres: t.R) -> t.Metric[t.T,t.R]: ...

def to_distance_matrix(d: t.Metric[int,t.R], n_rows: int, n_cols: int) -> t.ndarray: ...

def total_variation() -> t.Metric[t.ndarray,float]: ...

